import {Blueprint, BlueprintParameter, Change, astTools, InsertChange} from "clicore";
import * as path from "path";
import * as fs from "fs-extra";
import * as ts from "typescript";
import {Identifier} from "typescript";

const blueprintsDir = 'src/blueprints';

export default //noinspection JSUnusedGlobalSymbols
class NewProjectBlueprint extends Blueprint {
    name = 'unpack-blueprint-templates';
    description = 'Extract edit template files generated in blueprint generated by blueprint-from-files';
    options: BlueprintParameter[] = [
        {
            name: 'blueprint',
            type: 'enum',
            description: 'Blueprint to edit',
            choices: () => this.getUsableBlueprints(),
            require: true,
            ask: true
        },
    ];

    private filesMap: [string, string][];
    private blueprintName: string;


    prepare(options: {
        [k: string]: string | boolean;
    }): void {
        this.blueprintName = options.blueprint as string;
        this.filesMap = this.getFilesMap(options.blueprint as string);
    }

    generateChanges(): Change[] {
        return this.filesMap
            .map(([tpl, dest]) => [path.join(blueprintsDir, this.blueprintName, 'templates', tpl), path.join('.tmp', dest)])
            .map(([tpl, dest]) => new InsertChange(dest, 0, fs.readFileSync(tpl).toString()));
    }

    private getUsableBlueprints(): string[] {

        return fs.readdirSync(blueprintsDir)
            .map(p => {
                return {
                    name: p,
                    source: astTools.getSource(path.join(blueprintsDir, p, 'index.ts'))
                };
            })
            .filter(({name, source}) => this.isSourceValid(source))
            .map(({name}) => name)
    }

    private getFilesMap(blueprintName: string)  {
        const source = astTools.getSource(path.join(blueprintsDir, blueprintName, 'index.ts'));
        return [source]
            .map(s => this.getAstFilesMap(s))
            .map(n => n[0])
            .map(n => n.initializer as ts.ArrayLiteralExpression)
            .map(n => n.elements)
            .reduce((a,b) => a.concat(b), [] as ts.Expression[])
            .filter(e => e.kind === ts.SyntaxKind.ArrayLiteralExpression)
            .map((n: ts.ArrayLiteralExpression) => [n.elements[0], n.elements[1]])
            .filter(([n, o]) => n.kind === ts.SyntaxKind.StringLiteral && o.kind === ts.SyntaxKind.StringLiteral)
            .map(([n, o]: [ts.StringLiteral, ts.StringLiteral]) => [n.text, o.text]) as [string, string][];
    }

    private isSourceValid(source: ts.SourceFile): boolean {
        const filesAst = this.getAstFilesMap(source);
        if(filesAst.length === 1) {
            const initializer = filesAst[0].initializer;
            return !!initializer && (initializer.kind === ts.SyntaxKind.ArrayLiteralExpression);
        }
        return false;
    }

    private getAstFilesMap(source: ts.SourceFile): ts.VariableDeclaration[] {
        return astTools.findNodes(source, ts.SyntaxKind.VariableDeclaration)
            .filter((node: ts.VariableDeclaration) => (node.name as Identifier).text === 'filesMap') as ts.VariableDeclaration[];
    }

}
